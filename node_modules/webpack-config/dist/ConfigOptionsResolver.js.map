{"version":3,"sources":["../src/ConfigOptionsResolver.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAAA;;AAIA;;;;;;;;;;;;;;;;;;;;;AAiBA,IAAM,kBAAkB,uBAAxB;;;;;;IAKM,qB;;;;;;AAKF,iCAAY,cAAZ,EAA4B;AAAA;;AACxB,oBAAgB,GAAhB,CAAoB,IAApB,EAA0B,cAA1B;AACH;;;;;;;;;;;;;;;;;4BAyBO,M,EAAQ,O,EAAS;AACrB,UAAM,QAAQ,sBAAsB,OAAtB,CAA8B,MAA9B,EAAsC,OAAtC,CAAd;;AADqB;AAAA;AAAA;;AAAA;AAGrB,wDAAkC,gCAAsB,KAAtB,EAA6B,CAA7B,EAAgC,IAAhC,CAAlC,4GAAyE;AAAA;AAAA,cAA7D,MAA6D,eAA7D,MAA6D;AAAA,cAArD,IAAqD,eAArD,IAAqD;AAAA,cAA/C,GAA+C,eAA/C,GAA+C;;AACrE,cAAI,sBAAS,IAAT,CAAJ,EAAoB;AAChB,mBAAO,GAAP,IAAc,KAAK,cAAL,CAAoB,OAApB,CAA4B,IAA5B,CAAd;AACH;AACJ;AAPoB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AASrB,aAAO,KAAP;AACH;;;wBA7BoB;AACjB,aAAO,gBAAgB,GAAhB,CAAoB,IAApB,CAAP;AACH;;;;;;;;;;;4BAQc,M,EAAQ,O,EAAS;AAC5B,aAAO,wBAAW,OAAX,IAAsB,QAAQ,IAAR,CAAa,MAAb,EAAqB,MAArB,CAAtB,GAAqD,OAA5D;AACH;;;;;kBAoBU,qB","file":"ConfigOptionsResolver.js","sourcesContent":["import {\n    isFunction,\n    isString\n} from 'lodash';\nimport RecursiveIterator from 'recursive-iterator';\n\n/**\n * @function\n * @name ConfigTransform\n * @param {Config} config\n * @returns {Config|Object}\n */\n\n/**\n * @typedef {Object|ConfigTransform} ConfigOptions\n */\n\n/**\n * @private\n * @type {WeakMap}\n */\nconst STRING_RESOLVER = new WeakMap();\n\n/**\n * @class\n */\nclass ConfigOptionsResolver {\n    /**\n     * @constructor\n     * @param {ConfigStringResolver} stringResolver\n     */\n    constructor(stringResolver) {\n        STRING_RESOLVER.set(this, stringResolver);\n    }\n\n    /**\n     * @readonly\n     * @type {ConfigStringResolver}\n     */\n    get stringResolver() {\n        return STRING_RESOLVER.get(this);\n    }\n\n    /**\n     * @private\n     * @param {Config} config\n     * @param {ConfigOptions} options\n     * @returns {Object}\n     */\n    static valueOf(config, options) {\n        return isFunction(options) ? options.call(config, config) : options;\n    }\n\n    /**\n     * @param {Config} config\n     * @param {ConfigOptions} options\n     * @returns {Object}\n     */\n    resolve(config, options) {\n        const value = ConfigOptionsResolver.valueOf(config, options);\n\n        for (const {parent, node, key} of new RecursiveIterator(value, 1, true)) {\n            if (isString(node)) {\n                parent[key] = this.stringResolver.resolve(node);\n            }\n        }\n\n        return value;\n    }\n}\n\nexport default ConfigOptionsResolver;\n"]}